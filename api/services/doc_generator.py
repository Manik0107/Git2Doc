import subprocess
import os
import shutil
from pathlib import Path
from sqlalchemy.orm import Session
from api.database import Document
import PyPDF2


async def generate_documentation_task(
    doc_id: int,
    repo_url: str,
    prompt: str,
    db_session_maker
):
    """
    Background task to generate documentation using existing Git2Doc main.py
    
    This function:
    1. Creates output directory for the document
    2. Calls the existing main.py script with repo URL and prompt
    3. Moves generated files to the document's storage directory
    4. Updates database with file info and status
    """
    
    # Create output directory
    output_dir = Path(f"storage/documents/{doc_id}")
    output_dir.mkdir(parents=True, exist_ok=True)
    
    # Prepare the question/prompt for main.py
    question = prompt if prompt else "Generate comprehensive technical documentation for this repository, including architecture, implementation details, and usage instructions."
    
    # Create a temporary input file for the subprocess
    temp_input_file = output_dir / "input.txt"
    with open(temp_input_file, 'w') as f:
        f.write(f"{repo_url}\n{question}\n")
    
    try:
        # Call existing main.py in subprocess
        # We need to run from the Git2Doc root directory
        git2doc_root = Path(__file__).parent.parent.parent.absolute()
        
        # Set up environment with PYTHONPATH
        env = os.environ.copy()
        env['PYTHONPATH'] = str(git2doc_root)
        
        result = subprocess.run(
            ["python3", "main.py"],
            stdin=open(temp_input_file),
            cwd=git2doc_root,
            env=env,
            capture_output=True,
            text=True,
            timeout=600  # 10 minute timeout
        )
        
        if result.returncode != 0:
            print(f"Error generating documentation: {result.stderr}")
            # Update database with failed status
            db = db_session_maker()
            try:
                doc = db.query(Document).filter(Document.id == doc_id).first()
                if doc:
                    doc.status = "failed"
                    db.commit()
            finally:
                db.close()
            return
        
        # Move generated files to output directory
        # List of files generated by main.py
        generated_files = [
            "technical_documentation.pdf",
            "content.txt",
            "project_workflow.json",
            "project_workflow_diagram.png"
        ]
        
        pdf_path = None
        for filename in generated_files:
            source = git2doc_root / filename
            if source.exists():
                dest = output_dir / filename
                shutil.move(str(source), str(dest))
                if filename == "technical_documentation.pdf":
                    pdf_path = dest
        
        # Get PDF info
        pages = None
        size_str = None
        
        if pdf_path and pdf_path.exists():
            # Get number of pages
            try:
                with open(pdf_path, 'rb') as f:
                    pdf_reader = PyPDF2.PdfReader(f)
                    pages = len(pdf_reader.pages)
            except:
                pass
            
            # Get file size
            size_bytes = pdf_path.stat().st_size
            if size_bytes < 1024 * 1024:
                size_str = f"{size_bytes / 1024:.1f} KB"
            else:
                size_str = f"{size_bytes / (1024 * 1024):.1f} MB"
            
            # Extract repo name from URL
            repo_parts = repo_url.rstrip('/').split('/')
            repo_name = f"{repo_parts[-2]}/{repo_parts[-1]}" if len(repo_parts) >= 2 else repo_parts[-1]
            doc_name = f"{repo_name.replace('/', '-')}-docs.pdf"
            
            # Update database
            db = db_session_maker()
            try:
                doc = db.query(Document).filter(Document.id == doc_id).first()
                if doc:
                    doc.name = doc_name
                    doc.file_path = str(pdf_path.relative_to(git2doc_root))
                    doc.pages = pages
                    doc.size = size_str
                    doc.status = "completed"
                    db.commit()
            finally:
                db.close()
        
        # Clean up temp file
        if temp_input_file.exists():
            temp_input_file.unlink()
            
    except subprocess.TimeoutExpired:
        print(f"Documentation generation timed out for doc_id: {doc_id}")
        db = db_session_maker()
        try:
            doc = db.query(Document).filter(Document.id == doc_id).first()
            if doc:
                doc.status = "failed"
                db.commit()
        finally:
            db.close()
            
    except Exception as e:
        print(f"Error in document generation task: {str(e)}")
        db = db_session_maker()
        try:
            doc = db.query(Document).filter(Document.id == doc_id).first()
            if doc:
                doc.status = "failed"
                db.commit()
        finally:
            db.close()
