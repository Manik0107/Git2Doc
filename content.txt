# Code2Doc: Automated Documentation Generator

## 1. Problem Statement & Context

The Code2Doc repository addresses the problem of outdated or non-existent documentation for software projects. It aims to automate the generation of comprehensive, up-to-date technical documentation directly from a GitHub repository. The system facilitates understanding of the codebase, architecture, and key components without requiring manual effort.

> **Note:** The primary goal is to streamline documentation creation and maintenance by automatically extracting information from the source code and generating human-readable documentation.

## 2. High-Level Architecture

The system consists of the following major components:

1.  **GitHub Repository Reader:** Responsible for fetching the contents of the target GitHub repository. This uses the `GithubTools` class to interface with the GitHub API.
2.  **AI-Powered Analyzer:** Leverages the Google Gemini 2.0 Flash model (via the `google-genai` library and `agno` orchestration framework) to analyze the code and generate documentation content.
3.  **Documentation Generator:** Formats the analysis results into structured Markdown.
4.  **Workflow Diagram Generator:** Creates a visual representation of the project's architecture and data flow using the `graphviz` library, based on the `project_workflow.json` file.
5.  **PDF Converter:** Converts the generated Markdown documentation into a PDF document using `PyMuPDF (fitz)`.

The data flow is as follows:

1.  The `main.py` script receives a GitHub repository URL.
2.  `GithubTools` fetches the repository's content (files, code, etc.).
3.  The AI-powered analyzer processes the content and generates documentation text and workflow data.
4.  The workflow data is saved as `project_workflow.json`.
5.  `generate_project_workflow.py` creates a workflow diagram image from `project_workflow.json`.
6.  `doc_creation.py` converts the generated Markdown documentation and diagram into a PDF document.

External dependencies include:

*   GitHub API (via `PyGithub`)
*   Google Gemini 2.0 Flash (via `google-genai` and `OpenRouter`)
*   graphviz
*   PyMuPDF
*   Pillow
*   python-dotenv
*   crawl4ai


## Workflow Diagram

![Project Workflow Diagram](/Users/manikmanavenddram/Code2Doc/project_workflow_diagram.png)

*Figure: High-level workflow architecture of the project*


## 3. Key Design Decisions

*   **AI-Powered Analysis:** The decision to use Google Gemini 2.0 Flash for code analysis aims to automate understanding of the codebase and generation of documentation content. This reduces manual effort but introduces a dependency on the AI model and its associated costs and limitations.
*   **Markdown as Intermediate Format:** Using Markdown as an intermediate format simplifies the documentation generation process and allows for easy conversion to other formats like PDF and HTML.
*   **PDF Output:** Generating documentation as a PDF ensures consistent formatting and presentation. The use of `PyMuPDF` for PDF generation provides control over the document's appearance.
*   **Synchronous Execution:** The `main.py` script executes most tasks synchronously, including fetching repository content, AI analysis, documentation generation, and PDF conversion. This simplifies the code but can lead to longer execution times.

> **Key Decision:** Gemini 2.0 Flash was chosen to analyze code comments and generate documentation due to its balance of speed and quality vs Llama2 based on initial experimentation. Subsequent implementations may benefit from fine-tuning open source LLMs.

## 4. Repository Structure

```
Code2Doc/
├── main.py                         # Main orchestration script
├── doc_creation.py                 # PDF generation with image embedding
├── generate_project_workflow.py   # Workflow diagram renderer
├── requirements.txt                # Python dependencies
├── pyproject.toml                  # Project configuration
├── .env                            # Environment variables (create this)
├── assets/                         # Static assets
│   ├── workflow_diagram.png        # Sample workflow diagram
│   └── code2doc_documentation_preview.png
└── examples/                       # Sample outputs
    └── sample_output.pdf           # Example generated documentation
```

*   **`main.py`:** Orchestrates the documentation generation process.
*   **`doc_creation.py`:** Generates the PDF document.
*   **`generate_project_workflow.py`:** Generates the workflow diagram.
*   **`requirements.txt`:** Lists Python dependencies.
*   **`pyproject.toml`:** Project configuration file.
*   **`.env`:** Stores environment variables (API keys).
*   **`assets/`:** Contains static assets (diagrams, previews).
*   **`examples/`:** Contains sample output.

## 5. Core Concepts & Data Models

The key data models are:

*   **Repository:** Represents a GitHub repository, including its URL, files, and code.
*   **Documentation:** Represents the generated documentation content in Markdown format with sections like Introduction, Functions, and Classes.
*   **Workflow Diagram:** Represents the project's architecture and data flow as a graph with nodes and edges, stored in `project_workflow.json`.

```json
# Example project_workflow.json
{
  "nodes": [
    {"id": "1", "label": "GitHub Repository"},
    {"id": "2", "label": "AI Analyzer"},
    {"id": "3", "label": "Documentation"},
  ],
  "edges": [
    {"source": "1", "target": "2", "label": "Code Analysis"},
    {"source": "2", "target": "3", "label": "Generates"}
  ]
}
```

## 6. Public Interfaces

*   **`main.py`:** The primary entry point is the execution of the `main.py` script, which takes the GitHub repository URL as a command-line argument.
    ```bash
    python main.py <github_repository_url> "<question about the repo>"
    ```
    It reads repository content and initiates the documentation generation process. Key functions in `main.py` include:  Fetching repository information, running AI analysis using OpenRouter, storing workflow data to JSON, generating doc content, diagram, and the final PDF.
*   **`doc_creation.py`:** The `create_pdf` function is the main interface for generating the PDF documentation. It takes the documentation text and workflow diagram image as input.
    ```python
    def create_pdf(text_file, image_path, output_pdf):
        #Generates a PDF document
        pass
    ```

## 7. Execution Flow

1.  The user runs `main.py` with a GitHub repository URL and a specific question.
2.  `GithubTools` fetches the repository's content.
3.  The code submits the repository content to the AI model (Gemini 2.0 Flash) via the Agno orchestration framework using an OpenRouter configuration.
4.  The AI model analyzes the code, documentation, and comments in the git repository and produces documentation text. It also generates `project_workflow.json`, containing descriptions of the high-level project workflow in a structured format with node and edge definitions.
5.  `generate_project_workflow.py` consumes the `project_workflow.json`, then utilizes `graphviz` to generate the visual workflow diagram (`workflow_diagram.png`).
6.  `doc_creation.py` then uses MuPDF, along with the generated documentation text and the workflow diagram image, to produce a PDF document, including section headings and numbering where appropriate.
7.  The PDF document is saved to the `examples/` directory.

## 8. Configuration

The following environment variables are used:

*   `OPENROUTER_API_KEY`: Required for accessing the OpenRouter API, which is used to interface with the Gemini 2.0 Flash model. The absence of this key will generate a ValueError.

```bash
# .env example
OPENROUTER_API_KEY=your_openrouter_api_key
```

## 9. Failure Scenario Walkthrough

**Real World Failure Example**: API Rate Limit Exceeded.

**Step-by-Step Failure Path**: When the OpenRouter API rate limit is exceeded, the API returns an error. The Agno framework raises an exception, which is caught in `main.py`. The error message will be logged, and the documentation generation process terminates. As there is no retry or fallback implemented, the whole process fails.

**Recovery Mechanism**: There is currently no recovery mechanism implemented. The program exits upon encountering a rate limit error.

**Actual error types** raised and caught: Agno exceptions related to API calls.

## 10. Performance Characteristics & Repository Limits

*   **Repository Size Limits**: There are no explicitly defined file size limits.
*   **Performance limits**: The Gemini 2.0 Flash model's token limit is a constraint. Extremely large repositories might exceed this limit.
*   Time/space complexity: The AI analysis step has a dependency on the context size of the LLM, impacting the number of tokens that will be processed from the repo.

## 11. Security Considerations

*   Authentication and authorization: The application requires an OpenRouter API key, which must be stored securely. The API key should only be accessed through an environment variable and not hardcoded in the code.
*   Secrets handling: The `OPENROUTER_API_KEY` is read from the environment using the `python-dotenv` library.
*   AI-specific risks: Prompt injection and model hallucination are potential risks.

> **Warning:** Validate user inputs, especially the repository URL to prevent potential security vulnerabilities.

## 12. Testing Strategy

There are currently no explicit unit or integration tests in the provided repository.

## 13. Deployment & Operations

*   **Real build process:** The build process entails installing Python dependencies using `pip install -r requirements.txt`.
*   **Actual runtime dependencies:** Dependencies are specified in `requirements.txt` (agno, google-genai, python-dotenv, pymupdf, pillow, graphviz, crawl4ai, pygithub).
*   Observability: Logging statements exist throughout the application, primarily for debugging and informational purposes.

## 14. Known Limitations & Future Work

*   **Error Handling:** Robust error handling is currently lacking. The application should implement more comprehensive error handling and reporting mechanisms.
*   **Testing:** The absence of unit and integration tests makes it difficult to ensure the quality and reliability of the code.
*   **Context Limits:** Large repositories may exceed the context limits of the Gemini 2.0 Flash model.
*   **No Retry Logic:** The application does not implement retry logic for API calls.
*   **No built-in rate limiting**.

## Conclusion: System Maturity & Readiness

The Code2Doc repository is currently in an **Alpha** state. It generates documentation from a GitHub repository using AI analysis. However, it lacks robust error handling, testing, and retry logic. The core functionality is experimental and faces limitations with large repositories. Key limitations regarding error handling and API retries must be addressed before use in a production enviroment.